/*!
 * Module dependencies.
 */

var NodeJSDocument = require('./document'),
    EventEmitter = require('events').EventEmitter,
    MongooseError = require('./error'),
    Schema = require('./schema'),
    ObjectId = require('./types/objectid'),
    utils = require('./utils'),
    ValidationError = MongooseError.ValidationError,
    InternalCache = require('./internal');

/**
 * Document constructor.
 *
 * @param {Object} obj the values to set
 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
 * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id
 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
 * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.
 * @event `save`: Emitted when the document is successfully saved
 * @api private
 */

function Document(obj, schema, fields, skipId, skipInit) {
<<<<<<< HEAD
  if (!(this instanceof Document)) {
    return new Document(obj, schema, fields, skipId, skipInit);
  }
=======
  if ( !(this instanceof Document) )
    return new Document( obj, schema, fields, skipId, skipInit );
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d


  if (utils.isObject(schema) && !schema.instanceOfSchema) {
    schema = new Schema(schema);
  }

  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id
  schema = this.schema || schema;

  // Generate ObjectId if it is missing, but it requires a scheme
<<<<<<< HEAD
  if (!this.schema && schema.options._id) {
    obj = obj || {};

    if (obj._id === undefined) {
=======
  if ( !this.schema && schema.options._id ) {
    obj = obj || {};

    if ( obj._id === undefined ) {
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
      obj._id = new ObjectId();
    }
  }

<<<<<<< HEAD
  if (!schema) {
=======
  if ( !schema ) {
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
    throw new MongooseError.MissingSchemaError();
  }

  this.$__setSchema(schema);

  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = true;
  this.errors = undefined;

<<<<<<< HEAD
  // var schema = this.schema;

  if (typeof fields === 'boolean') {
=======
  //var schema = this.schema;

  if ('boolean' === typeof fields) {
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = this.schema.options && this.schema.options.strict;
    this.$__.selected = fields;
  }

  var required = this.schema.requiredPaths();
  for (var i = 0; i < required.length; ++i) {
    this.$__.activePaths.require(required[i]);
  }

  this.$__.emitter.setMaxListeners(0);
  this._doc = this.$__buildDoc(obj, fields, skipId);

<<<<<<< HEAD
  if (!skipInit && obj) {
    this.init(obj);
=======
  if ( !skipInit && obj ) {
    this.init( obj );
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
  }

  this.$__registerHooksFromSchema();

  // apply methods
<<<<<<< HEAD
  for (var m in schema.methods) {
    this[m] = schema.methods[m];
  }
  // apply statics
  for (var s in schema.statics) {
    this[s] = schema.statics[s];
=======
  for ( var m in schema.methods ) {
    this[ m ] = schema.methods[ m ];
  }
  // apply statics
  for ( var s in schema.statics ) {
    this[ s ] = schema.statics[ s ];
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
  }
}

/*!
 * Inherit from the NodeJS document
 */
Document.prototype = Object.create(NodeJSDocument.prototype);
Document.prototype.constructor = Document;

<<<<<<< HEAD
/*!
 * Module exports.
 */
=======


/*!
 * Module exports.
 */

>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
Document.ValidationError = ValidationError;
module.exports = exports = Document;
