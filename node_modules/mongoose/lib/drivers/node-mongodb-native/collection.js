<<<<<<< HEAD
=======

>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
/*!
 * Module dependencies.
 */

var MongooseCollection = require('../../collection'),
    Collection = require('mongodb').Collection,
    utils = require('../../utils');

/**
 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.
 *
 * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.
 *
 * @inherits Collection
 * @api private
 */

function NativeCollection() {
  this.collection = null;
  MongooseCollection.apply(this, arguments);
}

/*!
 * Inherit from abstract Collection.
 */

NativeCollection.prototype.__proto__ = MongooseCollection.prototype;

/**
 * Called when the connection opens.
 *
 * @api private
 */

NativeCollection.prototype.onOpen = function() {
<<<<<<< HEAD
  var _this = this;
=======
  var self = this;
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d

  // always get a new collection in case the user changed host:port
  // of parent db instance when re-opening the connection.

<<<<<<< HEAD
  if (!_this.opts.capped.size) {
    // non-capped
    return _this.conn.db.collection(_this.name, callback);
  }

  // capped
  return _this.conn.db.collection(_this.name, function(err, c) {
    if (err) return callback(err);

    // discover if this collection exists and if it is capped
    _this.conn.db.listCollections({name: _this.name}).toArray(function(err, docs) {
=======
  if (!self.opts.capped.size) {
    // non-capped
    return self.conn.db.collection(self.name, callback);
  }

  // capped
  return self.conn.db.collection(self.name, function(err, c) {
    if (err) return callback(err);

    // discover if this collection exists and if it is capped
    self.conn.db.listCollections({ name: self.name }).toArray(function(err, docs) {
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
      if (err) {
        return callback(err);
      }
      var doc = docs[0];
      var exists = !!doc;

      if (exists) {
        if (doc.options && doc.options.capped) {
          callback(null, c);
        } else {
<<<<<<< HEAD
          var msg = 'A non-capped collection exists with the name: ' + _this.name + '\n\n'
              + ' To use this collection as a capped collection, please '
              + 'first convert it.\n'
              + ' http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped';
=======
          var msg = 'A non-capped collection exists with the name: ' + self.name + '\n\n'
                  + ' To use this collection as a capped collection, please '
                  + 'first convert it.\n'
                  + ' http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped';
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
          err = new Error(msg);
          callback(err);
        }
      } else {
        // create
<<<<<<< HEAD
        var opts = utils.clone(_this.opts.capped);
        opts.capped = true;
        _this.conn.db.createCollection(_this.name, opts, callback);
=======
        var opts = utils.clone(self.opts.capped);
        opts.capped = true;
        self.conn.db.createCollection(self.name, opts, callback);
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
      }
    });
  });

  function callback(err, collection) {
    if (err) {
      // likely a strict mode error
<<<<<<< HEAD
      _this.conn.emit('error', err);
    } else {
      _this.collection = collection;
      MongooseCollection.prototype.onOpen.call(_this);
=======
      self.conn.emit('error', err);
    } else {
      self.collection = collection;
      MongooseCollection.prototype.onOpen.call(self);
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
    }
  }
};

/**
 * Called when the connection closes
 *
 * @api private
 */

NativeCollection.prototype.onClose = function() {
  MongooseCollection.prototype.onClose.call(this);
};

/*!
 * Copy the collection methods and make them subject to queues
 */

<<<<<<< HEAD
function iter(i) {
  NativeCollection.prototype[i] = function() {
    if (this.buffer) {
      this.addQueue(i, arguments);
      return;
    }

    var collection = this.collection,
        args = arguments,
        _this = this,
        debug = _this.conn.base.options.debug;

    if (debug) {
      if (typeof debug === 'function') {
        debug.apply(debug
            , [_this.name, i].concat(utils.args(args, 0, args.length - 1)));
      } else {
        this.$print(_this.name, i, args);
      }
    }

    try {
      return collection[i].apply(collection, args);
    } catch (error) {
      // Collection operation may throw because of max bson size, catch it here
      // See gh-3906
      if (args.length > 0 &&
          typeof args[args.length - 1] === 'function') {
        args[args.length - 1](error);
      } else {
        throw error;
      }
    }
  };
}

=======
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
for (var i in Collection.prototype) {
  // Janky hack to work around gh-3005 until we can get rid of the mongoose
  // collection abstraction
  try {
    if (typeof Collection.prototype[i] !== 'function') {
      continue;
    }
  } catch (e) {
    continue;
  }

<<<<<<< HEAD
  iter(i);
=======
  (function(i) {
    NativeCollection.prototype[i] = function() {
      if (this.buffer) {
        this.addQueue(i, arguments);
        return;
      }

      var collection = this.collection,
          args = arguments,
          self = this,
          debug = self.conn.base.options.debug;

      if (debug) {
        if ('function' === typeof debug) {
          debug.apply(debug
            , [self.name, i].concat(utils.args(args, 0, args.length - 1)));
        } else {
          this.$print(self.name, i, args);
        }
      }

      return collection[i].apply(collection, args);
    };
  })(i);
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
}

/**
 * Debug print helper
 *
 * @api public
<<<<<<< HEAD
 * @method $print
=======
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
 */

NativeCollection.prototype.$print = function(name, i, args) {
  console.error(
<<<<<<< HEAD
      '\x1B[0;36mMongoose:\x1B[0m %s.%s(%s) %s %s %s',
      name,
      i,
      this.$format(args[0]),
      this.$format(args[1]),
      this.$format(args[2]),
      this.$format(args[3]));
=======
    '\x1B[0;36mMongoose:\x1B[0m %s.%s(%s) %s %s %s',
    name,
    i,
    this.$format(args[0]),
    this.$format(args[1]),
    this.$format(args[2]),
    this.$format(args[3]));
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
};

/**
 * Formatter for debug print args
 *
 * @api public
<<<<<<< HEAD
 * @method $format
=======
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
 */

NativeCollection.prototype.$format = function(arg) {
  var type = typeof arg;
<<<<<<< HEAD
  if (type === 'function' || type === 'undefined') return '';
=======
  if ('function' === type || 'undefined' === type) return '';
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
  return format(arg);
};

/*!
 * Debug print helper
 */

<<<<<<< HEAD
function map(o) {
  return format(o, true);
}
function formatObjectId(x, key) {
  var representation = 'ObjectId("' + x[key].toHexString() + '")';
  x[key] = {inspect: function() { return representation; }};
}
function formatDate(x, key) {
  var representation = 'new Date("' + x[key].toUTCString() + '")';
  x[key] = {inspect: function() { return representation; }};
}
function format(obj, sub) {
  var x = utils.clone(obj, {retainKeyOrder: 1});
  var representation;

  if (x != null) {
    if (x.constructor.name === 'Binary') {
      x = '[object Buffer]';
    } else if (x.constructor.name === 'ObjectID') {
      representation = 'ObjectId("' + x.toHexString() + '")';
      x = {inspect: function() { return representation; }};
    } else if (x.constructor.name === 'Date') {
      representation = 'new Date("' + x.toUTCString() + '")';
      x = {inspect: function() { return representation; }};
    } else if (x.constructor.name === 'Object') {
=======
function format(obj, sub) {
  var x = utils.clone(obj, { retainKeyOrder: 1 });
  var representation;
  if (x != null) {
    if ('Binary' === x.constructor.name) {
      x = '[object Buffer]';
    } else if ('ObjectID' === x.constructor.name) {
      representation = 'ObjectId("' + x.toHexString() + '")';
      x = { inspect: function() { return representation; } };
    } else if ('Date' === x.constructor.name) {
      representation = 'new Date("' + x.toUTCString() + '")';
      x = { inspect: function() { return representation; } };
    } else if ('Object' === x.constructor.name) {
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
      var keys = Object.keys(x);
      var numKeys = keys.length;
      var key;
      for (var i = 0; i < numKeys; ++i) {
        key = keys[i];
        if (x[key]) {
<<<<<<< HEAD
          if (x[key].constructor.name === 'Binary') {
            x[key] = '[object Buffer]';
          } else if (x[key].constructor.name === 'Object') {
            x[key] = format(x[key], true);
          } else if (x[key].constructor.name === 'ObjectID') {
            formatObjectId(x, key);
          } else if (x[key].constructor.name === 'Date') {
            formatDate(x, key);
          } else if (Array.isArray(x[key])) {
            x[key] = x[key].map(map);
=======
          if ('Binary' === x[key].constructor.name) {
            x[key] = '[object Buffer]';
          } else if ('Object' === x[key].constructor.name) {
            x[key] = format(x[key], true);
          } else if ('ObjectID' === x[key].constructor.name) {
            (function(x) {
              var representation = 'ObjectId("' + x[key].toHexString() + '")';
              x[key] = { inspect: function() { return representation; } };
            })(x);
          } else if ('Date' === x[key].constructor.name) {
            (function(x) {
              var representation = 'new Date("' + x[key].toUTCString() + '")';
              x[key] = { inspect: function() { return representation; } };
            })(x);
          } else if (Array.isArray(x[key])) {
            x[key] = x[key].map(function(o) {
              return format(o, true);
            });
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
          }
        }
      }
    }
    if (sub) return x;
  }

  return require('util')
<<<<<<< HEAD
  .inspect(x, false, 10, true)
  .replace(/\n/g, '')
  .replace(/\s{2,}/g, ' ');
=======
    .inspect(x, false, 10, true)
    .replace(/\n/g, '')
    .replace(/\s{2,}/g, ' ');
>>>>>>> 28c6f978a4ba08bdae3bd531dac6bebf07cd4f5d
}

/**
 * Retreives information about this collections indexes.
 *
 * @param {Function} callback
 * @method getIndexes
 * @api public
 */

NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;

/*!
 * Module exports.
 */

module.exports = NativeCollection;
